\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{amssymb}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

%opening
\title{Auslagerung der Ausführung von Methoden der HYPRE Bibliothek in ein Cloudsystem
Recherche und Literaturverzeichnis}
\author{Thomas Rückert}

\begin{document}

\newenvironment{boxed}[1]
{\begin{center}Definition\\
\begin{tabular}{|p{0.9\textwidth}|}
\hline\\
\textbf{#1}\\\\
}
{
\\\\\hline
\end{tabular} 
\end{center}
}

\newcommand{\mycheckbox}[0]{\makebox[0pt][l]{$\square$}\raisebox{0.15ex}{\hspace{0.1em}$\checkmark$}}
\newcommand{\myuncheckbox}[0]{\makebox[0em][l]{$\square$}\raisebox{0.15ex}{\hspace{0.1em}$ $}}

\maketitle
\newpage

\begin{abstract}

\end{abstract}

\newpage

\tableofcontents
\listoftodos

\newpage

\section{Informationssammlung und Einführung in die relevanten Themen}

\subsection{Recherche zum Thema Cloud}

\subsubsection{Einführung und Grundbegriffe zu Cloudcomputing}

Entwicklung von monolitischen Systemen zu verteilten Anwendungen (SOA, Client/Server).
Ermöglicht Auslagerung kostenpflichtiger Berechnungen auf Server, `schwacher` Client kein Problem mehr.
Serverlast kann bei Anwendungen stark schwanken.
Zum Beispiel periodische Schwankungen Tag vs Nacht.
Klassischer Server muss die hohe Last stemmen, hat dann in anderen Perioden starken leerlauf.
Einmalige, sehr hohe Last bei besonderen Situationen (zum Beispiel durch einmalige, nicht wiederkehrende Sportevents wie Olympia/WM).
Klassischer Server könnte in diesem Zeitraum komplett ausfallen.
Cloud soll dynamische Resource sein, die sich je nach Bedarf skalieren kann.

\begin{figure}[htbp]
\centering
\caption{Übersicht Grundlagen Cloud Computing}
\label{fig:cloudComputingOverview}
\includegraphics[width=\textwidth]{graphics/cloudComputingOverview.pdf}
\end{figure}

Im Folgenden werden die eben kurz angeschnittenen Eigenschaften von Cloudsystemen näher betrachtet.
Ein Übersicht dazu ist in Abbildung \ref{fig:cloudComputingOverview} gegeben.

\paragraph{Verteilung der Last von Anwendungen}

Im Buch Cloud Computing Patterns von Christoph Fehling wird die Verteilung von Last in die folgenden Kategorien eingeteilt:

\begin{itemize}
 \item static workload
 \item periodic workload
 \item once-in-a-lifetime workload
 \item unpredictable workload
 \item continuously changing workload
\end{itemize}

\textbf{Static workload} beschreibt eine nicht oder nur minimal schwankende Last.
\textbf{Periodic workload} hat dagegen wiederkehrende Schwankungen. Diese können zum Beispiel von der Tageszeit abhängig sein.
Ein \textbf{Once-in-a-lifetime workload} ist eine einmalige Lastspitze.
\textbf{Unpredictable workload} liegt vor, wenn sich die Last ständig, jedoch unregelmäßig und zufällig verändert, sodass diese nicht vorhersehbar ist.
\textbf{Continuously changing workload} verändert sich in linear steigend oder fallend.

\subsubsection{NIST definition introduces five fundamental properties that characterize a cloud offering [CloudcomputingPatterns chap. 1.1]}

\begin{itemize}
 \item On-demand self-service
 \item Broad network access
 \item Measured service (pay-per-use)
 \item Resource pooling
 \item Rapid elasticity
\end{itemize}

\paragraph{On-demand self-service}
`Provisioning` und `decomissioning` als Aktivitäten zum Hinzufügen oder Entfernen von weiteren Ressourcen.
Das kann durch Benutzer über grafische oder Kommandozeilenschnittstellen geschehen oder automatisiert über eine API.
\paragraph{Broad network access}
Ein starkes Netzwerk [genauer definieren] ist essentiell um eine Verbesserung durch die Auslagerung von Berechnungen zu erreichen. 
So kann Zugriffszeit auf Daten weniger abhängig von ihrem pysikalischen Speicherort werden.
\paragraph{Measured service (pay-per-use)}
Durch die Nutzung von Cloudsystemen kann man stark von der Flexibilität der Ressourcen profitieren.
Diese Flexibilität muss sich auch im Bezahlmodell widerspiegeln.
\paragraph{Resource pooling}
Ein Cloudsystem benötigt einen (großen [genauer definieren]) Pool an Ressourcen.
Nur so kann Flexibilität für die Nutzer gewährleistet werden.
Um eine Austauschbarkeit der Ressourcen zu ermöglichen muss eine homogene Nutzung der Ressourcen existieren. [warum? flexible Nutzung, Kosten]
\paragraph{Rapid elasticity}
Elastizität von Cloudsystemen ermöglicht eine Effiziente Zuweisung von Ressourcen auf die Nutzer.
Der Ressourcepool muss dynamisch unter den Nutzern aufgeteilt werden können.

\subsubsection{IDEAL cloud-native applications [CloudcomputingPatterns chap. 1.2]}

\begin{itemize}
 \item Isolated state
 \item Distribution
 \item Elasticity
 \item Automated management
 \item Loose coupling
\end{itemize}

\paragraph{Isolated state}
Cloudanwendungen und ihre Komponenten sollten zustandslos sein.
Jede Ressource die zustandslos ist kann deutlich einfacher entfernt oder hinzugefügt werden als eine Ressource mit einem Zustand.
So können aufeinander folgende Interaktionen eines Nutzers beliebig auf verschiedene Ressourcen verteilt werden.
Eine Ressource die beispielsweise die erste Interaktion getätigt hat wird für weitere Interaktionen nicht mehr benötigt.
\paragraph{Distribution}
Cloudsysteme können auf viele verschiedene Standorte verteilt sein.
In jedem Fall bestehen sie aus vielen verschiedenen Ressourcen.
Anwendungen sollten daher aus mehreren Komponenten bestehen, die auf verschiedene Ressourcen verteilt werden können.
\paragraph{Elasticity}
Horizontale Skalierung statt vertikaler Skalierung:
Anwendung soll vom Hinzufügen weiterer Ressourcen profitieren können (horizontal).
Es soll nicht nur die `Verbesserung` einer Ressource eine bessere performance ermöglichen (vertikal).
Die Stärke von Cloudsystemen ist die dynamische Zuweisung von Ressourcen.
Cloudanwendungen müssen daher horizontal skalieren, also eine Parallelisierbarkeit vorweisen.
\paragraph{Automated management}
Durch die Elastizität können Ressourcen von Cloudanwendungen während der Laufzeit ständig hinzugefügt und entfernt werden.
Diese Aktionen sollten aufgrund von Monitoring der Systemlast ausgelöst werden.
Damit die Verwaltung der Ressourcen jederzeit schnell und entsprechend der aktuellen Lage stattfindet sollte sie automatisiert sein.
\paragraph{Loose coupling}
Da sich die verfügbaren Ressourcen der Anwendung während der Laufzeit ändern können sollten Komponenten möglichst unabhängig voneinander sein.
Das reduziert die Fehleranfälligkeit für die Fälle in denen Komponenten kurzzeitig nicht verfügbar sind. [wie?]
Da verteilte Anwendung diese Eigenschaft aufweisen sind Technologien wie Webservices, SOA, asynchrone Kommunikation relevant für Cloudanwendungen. [Technologien etwas weiter ausführen]

\subsubsection{Arten von Cloud}

\paragraph{Cloud Service Models}

\begin{itemize}
 \item Infrastructure as a Service (IaaS)
 \item Platform as a Service (PaaS)
 \item Software as a Service (SaaS)
\end{itemize}

\textbf{Infrastructure as a Service} gibt einem Zugang zu Netzwerk, Computern (unter umständen virtuell) und Speicher.
Es ist daher sehr nah an den schon länger existierenden und bekannten Hosted Server Lösungen. [wie zum beispiel, kurz erläutern]
\textbf{Platform as a Service} dageben entfernt die Notwendigkeit die unterliegende Infrastruktur zu verwalten.
Das betrifft Hardware sowie die Betriebssystemebene.
Man erhält eine Umgebung in der man seine Anwendung ausführen kann, ohne sich um Themen wie Updates, Kapazitäten von Speicher und anderen Ressourcen oder ähnliche typische Adminaufgaben kümmern zu müssen.
\textbf{Software as a Service} stellt ein Cloudmodell dar, welches sich eher an Endnutzer richtet.
Man erhält Zugriff auf eine Komplette Anwendung, wie zum Beispiel einen Mailserver.
Bei dieser Variante muss sich der Nutzer um keinerlei Aufgaben der Verwaltung der Software kümmern.

\paragraph{Organisatorische Arten von Clouds (Deployment Types)}

\begin{itemize}
 \item public
 \item private
 \item community
 \item hybrid
\end{itemize}

Eine \textbf{public cloud} ist für jeden verfügbar.
Eine \textbf{private cloud} dagegen nur für ein einziges Unternehmen oder einen Nutzer (od. Interessengemeinschaft).
Eine \textbf{community cloud} liegt zwischen den beiden ersten Varianten. 
Sie ist in der Regel für eine Menge von Unternehmen verfügbar.
Das kann notwendig werden, falls die Unternehmen an einem gemeinsamen Projekt arbeiten.
Bei \textbf{hybrid clouds} ist von mehreren Clouds die Rede.
Diese können aus verschiedenen Arten bestehen und sind untereinander verbunden.
So können sich unterschiedliche Anwendungen unter eigenständigen Umgebungen Informationen austauschen und interagieren.

\subsubsection{Cloudsysteme}

Vergleich in Tabelle


\paragraph{Verfügbare Cloudsysteme für public Clouds}

\subparagraph{Amazon EC2}

\url{https://www.youtube.com/watch?v=jLVPqoV4YjU&index=3&list=WL}
ssh Zugang siehe ab Minute 50

Instances mit verschiedenen verfügbaren Images = AMI (Linux, Windows).
ELB als elastischer Loadbalancer.
EBS - elastischer Blockstorage.
CloudWatch zum Überwachen von Ressourcen und Applikationen.
Kann zum automatischen Skalieren genutzt werden.
EC2 Actions - Recover, Stop, Terminate.
AWS CodeDeplay erlaubt deploying ohne downtime.
Amazon
Amazon EC2 Container Service ist ein Containermanagementservice zur Nutzung von Docker Containern.

Kostenloser Testzugang: \url{https://aws.amazon.com/free/}

\paragraph{Open Source Cloudsystem für private Clouds}

\begin{itemize}
 \item a guide to open source cloud \url{http://www.tomsitpro.com/articles/open-source-cloud-computing-software,2-754.html}
 \item 5 open source cloud platforms \url{http://solutionsreview.com/cloud-platforms/open-source-cloud-platforms-enterprise/}
\end{itemize}

\subparagraph{Sandstorm}

Link: \url{https://sandstorm.io/}\\

Kann als private oder public cloud genutzt werden.
Kann entweder im bestehenden Cloudsystem von Sandstorm genutzt werden oder selbst gehostet werden.
Im Cloudsystem von Sandstorm stehen SaaS und PaaS bereit.
Wenn man selbst hostet sind alle Service Modelle verfügbar, also zusätzlich auch IaaS.

Die verfügbaren Platformen stellen ein Linuxsystem bereit.
Daher kann jede beliebige Sprache genutzt werden welche auf Linux läuft.
Ist aber in erster Linie für SaaS-Apps gedacht.\\

Fazit:
wohl ungeeignet

\subparagraph{Openstack}

Link: \url{https://www.openstack.org/}\\
Openstack kostenlos testen: \url{http://trystack.org/}\\
devstack for getting started with openstack \url{http://docs.openstack.org/developer/devstack/}\\
install openstack on ubuntu \url{https://www.youtube.com/watch?v=jpk4i66-IU4}\\

why openstack? \url{https://www.youtube.com/watch?v=Bk4NoUsikVA}\\

Wird in erster Linie als IaaS verwendet.
Man kann bestehende Hardware mit Cloudstack in ein Cloudsystem umwandeln.
Es stehen verschiedene Services bereit, mit denen Kernanforderungen wie Speicher (Swift) oder Rechenleistung (Nova) befriedigt werden können.
Es gibt darüber hinaus weitere optionale Services für beispielsweise Datenbanken (Trove), Messaging (Zaqar), Container (Magnum) und viele Weitere.\\

Beispielkonfiguration: \url{https://www.openstack.org/software/sample-configs#high-throughput-computing}

GLANCE - Image Service
'Stores and retrieves virtual machine disk images. OpenStack Compute makes use of this during instance provisioning.'

NOVA - Compute
'Manages the lifecycle of compute instances in an OpenStack environment. Responsibilities include spawning, scheduling and decomissioning of machines on demand.'

KEYSTONE - Identity
'Provides an authentication and authorization service for other OpenStack services. Provides a catalog of endpoints for all OpenStack services.'

CINDER - Block Storage
'Provides persistent block storage to running instances. Its pluggable driver architecture facilitates the creation and management of block storage devices.'\\

Fazit:
modulare Services
passend für Anforderungen

\subparagraph{Apache Cloudstack}

\begin{boxed}{Apache Cloudstack \url{https://cloudstack.apache.org/}}
'Apache CloudStack is an open source Infrastructure-as-a-Service platform that manages and orchestrates pools of storage, network, and computer resources to build a public or private IaaS compute cloud.
\end{boxed}

\url{https://cloudstack.apache.org/}\\

With CloudStack you can:

Set up an on-demand elastic cloud computing service.
Allow end-users to provision resources' [http://docs.cloudstack.apache.org/en/latest/concepts.html]

private
IaaS

\subsubsection{Ressourcen}

\begin{itemize}
 \item amazon aws \url{https://aws.amazon.com/types-of-cloud-computing/}
 \item BOOK: cloud computing patterns \url{https://katalog.bibliothek.tu-chemnitz.de/Record/0012763915}
 \item raspberry pi private cloud \url{https://sc5.io/posts/a-private-raspberry-pi-cloud-with-arm-docker/}
 \item more raspberry \url{https://www.raspberrypi.org/forums/viewtopic.php?f=36&t=54997}
\end{itemize}

\subsection{HYPRE - Überblick über die Bibliothek}

HYPRE ist eine freie Software von Lawrence Livermore National Laboratory.
Es ist unter der GNU Lesser General Public License (Free Software Foundation) Version 2.1 lizensiert.
Der Funktionsumfang von HYPRE umfasst 'Scalable Linear Solvers and Multigrid Methods'.
Es steht als Bibliothek für die Sprachen C (nativ) und FORTRAN bereit.
Die aktuellste Version 2.11.1 ist seit dem 09.06.2016 verfügbar.
Bis zur vorletzten Version 2.10.1 wurde HYRPE auch mit dem Babel Interface bereit.
Dieses bot die Möglichkeit HYPRE von anderen Sprachen als C und FORTRAN zu nutzen.
So wurde im User Manual die Verwendung aus der Sprache Python beschrieben.

Nutzt MPI für Parallelisierbarung.

-performance?

\subsubsection{Funktionsumfang allgemein}

Wie bereits erwähnt wird der Funktionsumfang von HYPRE als 'Scalable Linear Solvers and Multigrid Methods' beschrieben.
-was heist das? was genau kann man lösen?

\paragraph{Conceptual Interfaces}
\paragraph{Solver Strategies}
\paragraph{Preconditioner(s)}

\subsubsection{Funktionsweise}

wie löst sie die probleme (groben einblick in die funktionsweise der methoden, falls möglich)

-wie funktioniert das? (lässt sich das beantworten)

\subsubsection{Verwendung}

\paragraph{Installation}

Download von \url{http://computation.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods/software} oder \url{https://github.com/LLNL/hypre}.
Innerhalb des Verzeichnis muss `configure` gefolgt von einem `make` ausgeführt werden.
Alternativ kann auch das build tool CMake eingesetzt werden.

\paragraph{Vorbereitungen vor einer Implementierung}

\paragraph{erste Implementierung}

liste siehe manual:

\begin{enumerate}
 \item Build any necessary auxiliary structures for your chosen conceptual interface. /
 Datenstrukturen für Gitter (Grid) und Schablone (Stencil) aufbauen, abhängig vom gewählten Interface.
 \item Build the matrix, solution vector, and right-hand-side vector through your chosen conceptual interface. /
 Matrix, Lösungsvektor, right-hand-side Vektor aufbauen. 
 Diese können über verschiedene HYPRE-calls mit den jeweiligen Informationen gefüllt werden.
 \item Build solvers and preconditioners and set solver parameters (optional). /
 Solver und preconditioner aufbauen und deren Parameter setzen.
 Je nach conceptual interface sind verschiedene solver verfügbar.
 \item Call the solve function for the solver. /
 Solver aufrufen damit das Problem berechnet wird.
 \item Retrieve desired information from solver. /
 Lösung vom solver abrufen.
\end{enumerate}

\paragraph{Ausführung, Test}

In der HYPRE-Bibliothek steht eine Reihe von Beipielen für die Benutzung zur Verfügung.
An dieser Stelle wird das Beispiel 5 näher betrachtet.
Dieses löst ein zweidimensionales Laplaceproblem (nxn) ohne Randbedingungen.
Die Anzahl der Unbekannten beträgt daher N=n².


\subsubsection{Ressourcen}

\begin{itemize}
 \item offiziell: \url{http://computation.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods}
 \item Übersicht Publikationen: \url{http://computation.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods/publications}
 \item Pursuing scalability for hypre's conceptual interfaces \url{http://dl.acm.org/citation.cfm?doid=1089014.1089018}
 \item (mehr) beispiele \url{https://redmine.scorec.rpi.edu/anonsvn/fastmath/docs/ATPESC_2013/Exercises/hypre/examples/README_files/c.html}
\end{itemize}

\subsection{Werkzeuge für die verteilte Ausführung}

\begin{itemize}
 \item c/c++ json lib benchmarks \url{https://github.com/miloyip/nativejson-benchmark}
 \item nur innerhalb der cloud (ungeeignet): Light-weight remote communication for high-performance cloud networks \url{http://ieeexplore.ieee.org/document/6483669/}
 \item Performance Analysis of High Performance Computing Applications on the Amazon Web Services Cloud \url{http://ieeexplore.ieee.org/abstract/document/5708447/}
\end{itemize}

\subsubsection{Using RPC inside of C}

RPC steht für Remote Procedure Call.
Sie bieten die Möglichkeit von Funktionsaufrufen in verteilten Systemen.
Im Gegensatz zu Protokollen wie HTTP oder REST sieht RPC wie ein Methodenaufruf aus.
Das Ziel ist die Ausführung einer bestimmten Prozedur, nicht das verwalten einer bestimmten Ressource.
Protokolle sind zum Beispiel XML-RPC und Json-RPC.

\begin{itemize}
 \item understanding rest and rpc for http \url{https://www.smashingmagazine.com/2016/09/understanding-rest-and-rpc-for-http-apis/}
 \item Implementing remote procedure calls \url{http://dl.acm.org/citation.cfm?id=357392}
 \item c++ json-rpc lib \url{https://github.com/cinemast/libjson-rpc-cpp/}
\end{itemize}

\paragraph{xml-rpc}

XML-RPC Bibliothek für C und C++ \url{http://xmlrpc-c.sourceforge.net/}.

Installation: 
In the simplest case, it's just a conventional\\
\begin{lstlisting}
./configure
make
make install
//And then, if Linux:
ldconfig
\end{lstlisting}

\paragraph{json-rpc}

information: \url{http://www.simple-is-better.org/json-rpc/}
wiki: \url{https://en.wikipedia.org/wiki/JSON-RPC}

json rpc server: \url{https://github.com/hmng/jsonrpc-c}

rpc client?: \url{https://groups.google.com/forum/#!topic/json-rpc/9O1dbQehU04}

tcp client: \url{http://jsonrpc-cpp.sourceforge.net/index.php?n=Main.HomePage}

json-rpc-libs:
\begin{itemize}
 \item \url{https://github.com/yeryomin/libjrpc}
 \item \url{https://github.com/jhlee4bb/jsonrpC}
 \item \url{https://github.com/hmng/jsonrpc-c}
 \item \url{https://github.com/pijyoi/jsonrpc}
\end{itemize}

\subparagraph{yeryomin/libjrpc}

\url{https://github.com/yeryomin/libjrpc}

install:

\begin{lstlisting}
git clone git@github.com:yeryomin/libjrpc.git
git clone git@github.com:yeryomin/libipsc.git
git clone git@github.com:yeryomin/libfmt.git
git clone git@github.com:zserge/jsmn.git
git clone git@github.com:yeryomin/liba.git

cd libipsc
make
sudo ln -s /path/to/libipsc.h /usr/include
cd ..

cd jsmn
make
sudo ln -s /path/to/jsmn.h /usr/include
cd ..

cd libfmt
make
sudo ln -s /path/to/libfmt.h /usr/include
cd ..

cd libjrpc
make
sudo ln -s /path/to/libjrpc.h /usr/include
\end{lstlisting}

so many unresolved dependencies.............. wow

\subparagraph{jhlee4bb/jsonrpC}

(needs libwebsockets installed: `yaourt libwebsockets` etc.)

\begin{lstlisting}
git clone git@github.com:jhlee4bb/jsonrpC.git
cd jsonrpC
mkdir build
cd build
cmake ..
make
build output left in jsonrpc-x.y
\end{lstlisting}

völlig veraltet - websocket-lib ist inziwschen komplett inkompatibel

\paragraph{json vs xml}

\subsubsection{Calling Python from C}

\paragraph{ressourcen}

\url{https://docs.python.org/2.5/ext/callingPython.html}
\url{https://www.codeproject.com/articles/11805/embedding-python-in-c-c-part-i}

better

\url{http://www.linuxjournal.com/article/8497}
\url{https://www.codeproject.com/articles/820116/embedding-python-program-in-a-c-cplusplus-code}

\paragraph{basics}

\begin{lstlisting}
#include <python3.6m/Python.h>

int main()
{
  Py_Initialize();
  PyRun_SimpleString(
    "print('Hello World from Embedded Python!!!')"
  );
  Py_Finalize();
}
\end{lstlisting}

kompilieren von c-code mit python3.6

\begin{lstlisting}
cc prog.c -o prog.o -I/usr/include/python3.6m -lpython3.6m 
  -lm -L/usr/lib/python3.6
\end{lstlisting}

\subsubsection{spring-server framework}

\url{https://github.com/bartobri/spring-server}

\begin{lstlisting}
git clone git@github.com:bartobri/spring-server.git
\end{lstlisting}

\subsubsection{Service}
\subsubsection{Socket}

\newpage

\section{Vergleich verschiedener Technologien und Werkzeuge für den Einsatz bei der Implementierung}

\subsection{Ressourcen}

\begin{itemize}
 \item HPC in der Cloud \url{http://grids.ucs.indiana.edu/ptliupages/publications/cloud_handbook_final-with-diagrams.pdf}
\end{itemize}


\subsection{'private' vs 'public' Cloud}

\begin{itemize}
 \item gibt es open source cloud systeme? welche?
 \item welche public clouds gibt es (zB aws, windows azure, adobe creative)
 \item was sind unterschiede (neben dem access, zB performance?)
\end{itemize}

\subsection{Technologie}


\todo{Was muss zwischen Client und Server übertragen werden:}

Müssen wir structs übertragen?
Reicht es inbuild data types zu übertragen und structs werden nur auf dem server erstellt?
Beeinflusst die Entscheidung der Wahl des Frameworks.

\begin{itemize}
 \item welche Werkzeuge für die kommunikation zwischen client und cloud
 \item rpc, socket, service ...
 \item abwägen zwischen performance, aufwand ...
 \item welche framework könnten genutzt werden
\end{itemize}


\subsection{Cloudtyp}

wird evtl schon teilweise in abschnitt 1 (allgemeines zur cloud) abgedeckt

\begin{itemize}
 \item Infrastructure as a Service (IaaS)
 \item Platform as a Service (PaaS)
 \item Software as a Service (SaaS)
 \item aber entscheidend: wie eignen sich diese typen für `unsere` Implementierung
\end{itemize}

\subsection{Sprache}

\begin{itemize}
 \item hardware-nah: C/C++ (bessere performance)
 \item vs netzwerknah: (bessere möglichkeiten die kommunikation zu Implementieren)
 \item kann eine hybridform eingsetzt werden? 
 zB (micro-)service: bib in c kommuniziert mit client-backend in php, dieses führt die calls zum server aus
\end{itemize}

\subsection{Vergleich ausgewählter Cloudsysteme in einer Tabelle}

anhand relevanter (für das Projekt) Eigenschaften

\begin{table}[]
\centering
\caption{My caption}
\label{my-label}
\begin{tabular}{lllll}
Cloudsystem & private       & PaaS & ... &  \\
Openstack   & \mycheckbox   &  &     &  \\
Apache CS   & \mycheckbox   &  &     &  \\
Amazon AWS  & \myuncheckbox & \mycheckbox &     & 
\end{tabular}
\end{table}

\newpage

\section{(Test-)Installation OpenStack}

\url{http://docs.openstack.org/developer/devstack/}\\
\url{https://www.youtube.com/watch?v=jpk4i66-IU4}\\
\url{http://ronaldbradford.com/blog/setting-up-ubuntu-on-virtualbox-for-devstack-2016-03-30/}\\
\url{http://ronaldbradford.com/blog/setting-up-ubuntu-using-vagrant-2016-04-01/}\\
\url{http://ronaldbradford.com/blog/downloading-and-installing-devstack-2016-04-02/}\\

\paragraph{Ubuntu 16.04 in Vagrant aufsetzen}

\begin{enumerate}
 \item \begin{verbatim}vagrant init bento/ubuntu-16.04\end{verbatim}
 \item Vagrantfile anpassen. Es sollten mindestens 4GB RAM zugewiesen werden, damit OpenStack performant läuft.\\
\begin{minipage}{\textwidth}
\begin{lstlisting}
Vagrant.configure(2) do |config|
  config.vm.box = "bento/ubuntu-16.04"
  config.vm.network "private_network", type: "dhcp"
 
  config.vm.provider "virtualbox" do |v|
    v.memory = 4096
  end
end
\end{lstlisting}
\end{minipage}
 \item \begin{verbatim}vagrant up\end{verbatim}
 \item \begin{verbatim}vagrant ssh\end{verbatim}
\end{enumerate}
 
\paragraph{Devstack installieren}
  
\begin{enumerate}
 \item \begin{verbatim}git clone https://git.openstack.org/openstack-dev/devstack \end{verbatim}
 \item  \begin{verbatim}cd devstack\end{verbatim}
 \item Bei Bedarf zu einem (älteren) stable release wechseln: \begin{verbatim}git checkout stable/ocata\end{verbatim} oder \begin{verbatim}git checkout stable/mitaka\end{verbatim} Die master-branch kann auch genutzt werden.
 \item \begin{verbatim}ifconfig enp0s8 | grep addr\end{verbatim}
 \item \begin{verbatim}inet addr kopieren\end{verbatim}
 \item \begin{verbatim}cp samples/local.conf .\end{verbatim}
 \item \begin{verbatim}HOST_IP="xxx.xxx.xxx.xxx"\end{verbatim}
 \item \begin{verbatim}echo "HOST_IP=${HOST_IP}" >> local.conf\end{verbatim}
 \item Es muss ein user mit sudo-rechten (ohne passwort) existieren, der nicht root ist. Der Standarduser vagrant ist dafür geeignet.
 \item \begin{verbatim}./stack.sh\end{verbatim}
\end{enumerate}

Am Ende der erfolgreichen Installation erscheint die folgende Ausgabe in etwa so.
Von hier können die nötigen Informationen für das weitere Vorgehen entnommen werden.

\begin{minipage}{\textwidth}
\begin{lstlisting}
=========================
DevStack Component Timing
=========================
Total runtime         3644

run_process            87
test_with_retry         7
apt-get-update         12
pip_install           881
restart_apache_server  20
wait_for_service       61
git_timed             355
apt-get               457
=========================



This is your host IP address: 172.28.128.3
This is your host IPv6 address: ::1
Horizon is now available at http://172.28.128.3/dashboard
Keystone is serving at http://172.28.128.3/identity/
The default users are: admin and demo
The password: nomoresecret
\end{lstlisting}
\end{minipage}

\paragraph{Openstack (Horizon) starten}

Die folgenden Informationen sind abhängig von der Konfiguration.
Für dieses Beispiel sind folgende Daten notwendig.

\begin{enumerate}
 \item \url{http://172.28.128.3/dashboard} in einem Browser öffnen
 \item Benutzername admin oder demo
 \item Password nomoresecret
\end{enumerate}

\paragraph{Reboot}

\url{https://ask.openstack.org/en/question/5423/rebooting-with-devstack/}
Wenn die Vagrantbox herunter gefahren wurde muss devstack nach einem erneuten Start ebenfalls neu gestartet werden.

\begin{verbatim}
 ./unstack.sh
 ./stack.sh
\end{verbatim}


Bei einem erneuten Ausführen von stack.sh würden jedoch alle Datenbanken neu erstellt werden.
Das würde zu einem kompletten Datenverlust führen.

\begin{verbatim}
 screen -c stack-screenrc
\end{verbatim}

\newpage

\section{Zukünftige, weiterführende Arbeiten}

eventuell werden Teile von hier in die aktuelle Arbeit verschoben

\begin{itemize}
 \item Skalierbarkeit der Cloud (einsetzen)
 \item Vorteile der Auslagerung:
  \begin{itemize}
    \item performance
    \item speicher
    \item lösbarkeit (nur remote überhaupt lösbar)
  \end{itemize}

\end{itemize}


\end{document}
